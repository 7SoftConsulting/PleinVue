link:#introduction[[.underline]#Introduction#]

link:#caractéristiques-de-programmation[[.underline]#Caractéristiques de programmation#]

link:#Installation[[.underline]#Installation#]

link:#Mon-premier-projet[[.underline]#Mon premier projet#]

link:#La-classe-Application[[.underline]#La classe Application#]

link:#Les-classes-base-de-données[[.underline]#Les classes base de données#]

link:#La-classe-Zone-Web-Simple[[.underline]#La classe Zone Web Simple#]

link:#La-classe-Tache-Programmée[[.underline]#La classe Tache Programmée#]

link:#La-classe-Service-Persistant[[.underline]#La classe Service Persistant#]

link:#Organisation-dune-solution-PHP-PV[[.underline]#Organisation d’une solution PHP-PV#]

== Introduction

PHP-PV est une bibliothèque PHP qui permet de réaliser des solutions pour entreprises.

Elle offre des objets PHP pour créer :

* Des applications web, jQuery et Bootstrap
* Des processus web et consoles asynchrones
* Des scripts d’invite de commande
* Des serveurs sockets
* Des services persistants
* Des services web SOAP 1.1, SOAP 1.2 et JSON-RPC

Les avantages offerts par PHP-PV :

* La philosophie de programmation est facile à apprendre
* La rapidité pour produire des applications d’entreprise
* Chaque objet créé peut accéder aux autres dans l’environnement

== Caractéristiques de programmation

=== Méthode de programmation

Pour utiliser PHP-PV efficacement, vous devez bien connaître ces concepts :

* hériter les classes
* réécrire des méthodes
* utiliser les objets référencés dans d’autres objets
* Utiliser les noms des classes comme paramètre de méthode

=== Projets prêts à l’emploi

Les créateurs et contributeurs ont posté plusieurs projets personnalisables.

Une fois le projet téléchargé, Vous devrez :

* Modifier le nom d’espace dans les constantes
* Modifier le nom d’espace dans les noms de classe
* Modifier les variables et constantes dans le fichier de configuration

Vous pouvez réaliser facilement ces actions avec les éditeurs de code source (Notepad++, Sublime Text, Eclipse, Ms Visual Studio, Visual Studio Code, NetBeans, …).

== Installation

=== Structure de solution

Vous devez copier la bibliothèque PHP-PV directement dans le dossier RACINE de votre serveur WEB.

[.underline]#Exemples# :

* Sous Apache, c’est le dossier « /srv/www/hdtocs » ou « /var/www/html »
* Sous Wamp, c’est le dossier « C:/…/wamp/www »
* Sous XAMPP, c’est le dossier « C:/…/xampp/www »

=== Dossiers principaux

La bibliothèque contient les répertoires suivants :

* *Pv* : Dossier contenant les classes principales
* *Sws* : Dossier contenant les classes pour créer des sites web comme un CMS (Déprécié)
* *misc* : Dossier contenant les librairies PHP tiers
* *Ak* : Dossier contenant les classes d’authentification
* *Common* : Dossier contenant d’autres librairies communes
* *ExpatXml* : Dossier contenant les classes pour analyser les fichiers Xml
* *NativeThread* : Dossier contenant les classes d’exécution de processus en asynchrone
* *CommonDB* : Dossier contenant les classes de base de données

== Mon premier projet

=== Création du dossier solution

Vous allez créer un dossier pour votre solution, au même niveau que le dossier « PHP-PV ».

Exemple :

image:extracted-media/media/image1.png[image,width=447,height=249]

Ensuite, créez un fichier PHP dans ce dossier.

Comme première instruction, incluez le fichier « *../PHP-PV/Pv/Base.class.php* »

[source,php]
<?php
include dirname(__FILE__)."/../PHP-PV/Pv/Base.class.php" ;


=== Déclaration de l’application

Dans ce fichier PHP, déclarez votre classe *ApplicationSolution1*, qui héritera de la classe *PvApplication*.

[source,php]
class ApplicationSolution1 extends PvApplication {
}

=== Déclaration de la zone Web

Juste après, déclarez la zone web.

[source,php]
class ZoneWebSolution1 extends PvZoneWebSimple {
// Forcer l’affichage de la zone web, sans tenir compte du chemin du script
public $AccepterTousChemins = 1 ;
}

Retournez dans votre classe *ApplicationSolution1*, réécrivez la méthode *ChargeIHMs*(). Vous invoquerez la méthode *InsereIHM()* pour inscrire la Zone Web.

[source,php]
class ApplicationSolution1 extends PvApplication {
protected function ChargeIHMs() {
$this->InsereIHM("zoneWeb", new ZoneWebSolution1()) ;
}
}

=== Déclaration du script par défaut

Créez maintenant un script web, qui affichera « Hello World ».

Ce script héritera de la classe PvScriptWebSimple. Réécrivez sa méthode RenduSpecifique() pour retourner le texte à afficher.

[source,php]
class ScriptAccueilSolution1 extends PvScriptWebSimple {
public function RenduSpecifique() {
return "Hello World" ;
}
}

Maintenant réécrivez la méthode ChargeScripts() de la zone web au-dessus. Utilisez à l’intérieur la méthode InsereScriptParDefaut() pour inscrire le Script que vous avez créé.

[source,php]
class ZoneWebSolution1 extends PvZoneWebSimple {
// Forcer l’affichage de la zone web, sans tenir compte du chemin du script
public $AccepterTousChemins = 1 ;
protected function ChargeScripts() {
$this->InsereScriptParDefaut(new ScriptAccueilSolution1()) ;
}
}

=== Démarrer l’application

Il ne vous reste plus qu’à démarrer l’application.

Créez une variable de type *ApplicationSolution1*, puis invoquez sa méthode Execute().

[source,php]
$app = new ApplicationSolution1() ;
$app->Execute() ;

Voici le code source complet :

[source,php]
<?php
include dirname(__FILE__)."/../PHP-PV/Pv/Base.class.php" ;
class ApplicationSolution1 extends PvApplication {
protected function ChargeIHMs() {
$this->InsereIHM("zoneWeb", new ZoneWebSolution1()) ;
}
}
class ZoneWebSolution1 extends PvZoneWebSimple {
// Forcer l’affichage de la zone web, sans tenir compte du chemin du script
public $AccepterTousChemins = 1 ;
protected function ChargeScripts() {
$this->InsereScriptParDefaut(new ScriptAccueilSolution1()) ;
}
}
class ScriptAccueilSolution1 extends PvScriptWebSimple {
public function RenduSpecifique() {
return "Hello World" ;
}
}
$app = new ApplicationSolution1() ;
$app->Execute() ;
?>

Pour visualiser le retour, ouvrez votre navigateur (Internet Explorer, IE Edge, Chrome, Firefox).

Exécutez l’adresse du script PHP.

http://localhost/Solution1/index.php

Vous verrez le résultat ainsi :

image:extracted-media/media/image2.png[image,width=441,height=176]

=== Inscrire d’autres scripts web

Dans une zone, vous pouvez inscrire plusieurs Scripts. Ainsi ces scripts seront accessibles à partir du paramètre GET « *appelleScript* ».

Nous allons ajouter un script « a_propos ». A l’interieur du fichier PHP, déclarez le script *ScriptAProposSolution1* après *ScriptAccueilSolution1*.

[source,php]
class ScriptAProposSolution1 extends PvScriptWebSimple {
public function RenduSpecifique() {
return "A Propos de notre entreprise !" ;
}
}

Ensuite, insérez ce script dans la méthode *ChargeScripts()* de *ZoneWebSolution1*.

[source,php]
class ZoneWebSolution1 extends PvZoneWebSimple {
// Forcer l’affichage de la zone web, sans tenir compte du chemin du script
public $AccepterTousChemins = 1 ;
protected function ChargeScripts() {
$this->InsereScriptParDefaut(new ScriptAccueilSolution1()) ;
$this->InsereScript("a_propos", new ScriptAProposSolution1()) ;
}
}

Affichez ce lien pour voir le résultat :

http://localhost/Solution1/index.php?**appelleScript**=*a_propos*

== La classe Application 

=== Méthodes principales

Voici, brièvement, les méthodes principales d’une application.

[cols=",,",options="header",]
|==========================================================================================================================================================
|*Nom* |*Contexte* |*Description*
|*InitConfig()* |A réécrire |Définit les membres à l’instanciation de l’application
|*Execute()* |A partir d’une instance |Exécute l’application
|*ChargeConfig()* a|
A réécrire

Invoquée par Execute().

|Définit les membres pour l’exécution de l’application.
|*ChargeIHMs()* a|
A réécrire

Invoquée par ChargeConfig()

|Définit les Interfaces (Web, Console, SOAP, …) de l’application
|*ChargeTachesProgs()* a|
A réécrire

Invoquée par ChargeConfig()

|Invoquée par la méthode ChargeConfig().Définit les tâches programmées de l’application.
|*ChargeServsPersists()* a|
A réécrire

Invoquée par ChargeConfig()

|Invoquée par la méthode ChargeConfig()
|*InsereIHM(string $nom, & PvIHM $ihm)* |Utiliser dans *ChargeIHMs()* |Inscrit une IHM (Interface web, console ou SOAP) dans l’application
|*InsereTacheProg(string $nom, & PvTacheProg $tacheProg)* |Utiliser dans *ChargeTachesProgs()* |Inscrit une tâche programmée dans l’application
|*InsereServPersist(string $nom, & PvServicePersist $servPersist)* |Utiliser dans *ChargeServsPersists()* |Inscrit un service persistant dans l’application
|==========================================================================================================================================================

=== Les élements d’application

L’élément d’application est la classe *PvElementApplication*. Elle est le noyau des interfaces web, console, SOAP, services et tâche programmée.

Quand l’application s’exécute, elle parcourt tous ses éléments d’application. Si l’un d’entre eux est actif, l’application démarre l’exécution de cet élément et arrête le parcourt.

Pour savoir si un élément d’application est actif, l’application a deux possibilités :

* Vérifier si le chemin relatif de l’élément est celui du script PHP. La propriété est « *CheminFichierRelatif* ».
* La propriété « *AccepterTousChemins* » de cet élément a pour valeur 1.

== Les classes base de données

=== Présentation

PHP-PV inclut les classes de base de données CommonDB.

Ces bases de données offrent les avantages suivants :

* Elles ferment automatiquement les connexions à la fin du script PHP, ou après chaque exécution d’une requête.
* Elles possèdent des méthodes pour sélectionner, insérer, modifier et supprimer des lignes à partir de tableau
* Elles possèdent des méthodes pour invoquer les fonctions SQL Natives (fonction pour obtenir la date du jour, …)

=== Propriétés et Méthodes principales

[cols=",",options="header",]
|========================================================================================================================================================================================================================================================================================
|*Propriété/Méthode* |*Rôle*
|$ConnectionParams = array() |Contient les paramètres de connexion à la base de données. Les clés du tableau sont : +
- server : Hote du serveur de base de données +
- schema : Nom de la base de données +
- user : Login de l’utilisateur +
- password : Mot de passe de l’utilisateur. +
Ces informations sont interprétées différemment du type de base de données.
|InitConnectionParams() |Définit les paramètres de connexion.
|InitConnection() |Ouvre la connexion sur la base de données
|FinalConnection() |Ferme la connexion à la base de données
|$ParamPrefix |Préfixe natif des paramètres de la base de données
|$AutoCloseConnection |Ferme automatiquement les connexions après l’exécution d’une requête SQL. Valeur par défaut : *true*
|RunSql($sql, $params=array()) |Exécute le requête *$sql* sur la base de données, en appliquant les paramètres *$params*. Renvoie un résultat Booléen.
|FetchSqlRows($sql, $params=array()) |Exécute la requête *$sql* sur la base de données, en appliquant les paramètres *$params*. Renvoie un tableau contenant les résultats. Chaque ligne trouvée est un tableau associatif dont les clés sont les colonnes de la requête.
|FetchSqlRow ($sql, $params=array()) |Exécute la requête *$sql* sur la base de données, en appliquant les paramètres *$params*. Renvoie la 1^ère^ ligne. Cette ligne est un tableau associatif dont les clés sont les colonnes de la requête. Elle ramène *false* s’il y a une exception.
|InsertRow($tableName, $row=array()) |Insère la ligne *$row* dans la table *$tableName*. Les clés de la ligne $row doivent être celles des colonnes de *$tableName*. L’insertion s’appliquera uniquement sur les colonnes renseignées.
|UpdateRow($tableName, $row=array(), $where, $params=array()) |Mets à jour la ligne *$row* dans la *$tableName*, quand la condition *$where* est respectée.
|DeleteRow($tableName, $where, $params=array()) |Supprime les lignes dans la *$tableName*, quand la condition *$where* est respectée.
|RunStoredProc($procName, $params=array()) |Exécute la procédure stockée *$procName* avec les paramètres *$params*.
|FetchStoredProcRows($procName, $params=array()) |Exécute et renvoie les résultats de la procédure *$procName* avec les paramètres *$params*.
|FetchStoredProcRow($procName, $params=array()) |Exécute et renvoie la 1^ère^ ligne résultat de la procédure *$procName* avec les paramètres *$params*.
|========================================================================================================================================================================================================================================================================================

=== Méthodes Natives SQL

Ces méthodes ramènent la fonction SQL adéquate.

[cols=",",options="header",]
|============================================================================================================================================
|*Méthode* |*Description*
|SqlConcat($list) |Concatène les éléments du tableau $list.
|SqlNow() |Ramène la date et heure actuelle
|SqlToDateTime($expr) |Convertit la valeur *$expr* en datetime.
|SqlToTimestamp($expr) |Convertit la valeur *$expr* en timestamp.
|SqlAddSeconds($expr, $val) |Ajoute la valeur *$val* secondes à la valeur *$expr*
|SqlAddMinutes($expr, $val) |Ajoute la valeur *$val* minutes à la valeur *$expr*
|SqlAddHours($expr, $val) |Ajoute la valeur *$val* heures à la valeur *$expr*
|SqlAddDays($expr, $val) |Ajoute la valeur *$val* jours à la valeur *$expr*
|SqlAddMonths($expr, $val) |Ajoute la valeur *$val* mois à la valeur *$expr*
|SqlAddYears($expr, $val) |Ajoute la valeur *$val* années à la valeur *$expr*
|SqlDateDiff ($expr1, $expr2) |Calcule le nombre de secondes entre *$expr1* et *$expr2*
|SqlLength($expr) |Retourne le nombre de caractères dans la chaîne *$expr*
|SqlSubstr($expr, $start, $length=0) |Extrait dans *$expr* la chaine commençant par *$start*, de taille *$length*.
|SqlIndexOf($expr, $search, $start=0) |Renvoie l’indice de l’occurrence de *$search* à partir de *$start* (valeur minimale 0) dans *$expr*.
|SqlIsNull($expr) |Vérifie si *$expr* est la valeur Nulle de la base de données
|SqlStrToDateTime($dateName) |Convertit la chaine *$dateName* au format datetime de la base de données
|SqlDateToStrFr($dateName, $includeHour=0) a|
Convertit la date *$dateName* au type chaine de caractère de la base de données. Si *$includeHour* est *1*, l’heure sera convertie également.

Le format supporté est dd/mm/yyyy.

|SqlToInt($expression) |Convertit l’expression *$expression* au type INTEGER de la base de données
|SqlToDouble($expression) |Convertit l’expression *$expression* au type DOUBLE de la base de données
|SqlToString($expression) |Convertit l’expression *$expression* au type Chaine de Caractères de la base de données
|============================================================================================================================================

=== Les fournisseurs de base de données

==== MySQL

La classe est *MysqliDB*. Elle utilise l’extension PHP *Mysqli*.

Pour recevoir les données encodés en iso-8859-1, modifiez la classe ainsi :

[source,php]
class MysqlDBIso extends MysqliDB // Changer le nom de la classe
{
public $AutoSetCharacterEncoding = 1 ;
public $MustSetCharacterEncoding = 1 ;
public $SetCharacterEncodingOnFetch = 1 ;
public $CharacterEncoding = 'utf8' ;
public function DecodeRowValue($value)
{
if(! is_string($value))
{
return parent::DecodeRowValue($value) ;
}
return html_entity_decode(htmlentities($value, ENT_COMPAT, 'ISO-8859-1')) ;
}
public function EncodeParamValue($value)
{
if(! is_string($value))
{
return parent::EncodeParamValue($value) ;
}
return html_entity_decode(htmlentities($value, ENT_COMPAT, 'UTF-8'), ENT_COMPAT, 'ISO-8859-1') ;
}
}

==== Oracle

La classe *OciDB* permet de manipuler une base de données Oracle de 8g à 12c.

Elle utilise l’extension PHP oci8-11g.

==== Sql Server

La classe *SqlSrvDB* manipule une base de données SQL Server. Elle utilise l’extension PHP sqlsrv.

== La classe Zone Web Simple

=== Propriétés HTML

La zone web possède des propriétés pour le rendu HTML.

[cols=",,",options="header",]
|==============================================================================
|*Propriété* |*Rôle* |*Contenu HTML généré*
|EncodageDocument |Fixe l’encodage de la page web |<meta charset="$valeur" />
|MotsCleMeta |Mots clé META |<meta name="keywords" value="$valeur" />
|DescriptionMeta |Description META |<meta name="description" value="$valeur" />
|LangueDocument |Langage du document |<html lang="$valeur">
|TitreDocument |Titre du document |<title>$valeur</title>
|ViewportMeta |Viewport Meta |<meta name="viewport" content="$valeur" />
|==============================================================================

Exemple :

[source,php]
<?php
include dirname(__FILE__)."/PHP-PV/Pv/Base.class.php" ;
class MonApplication1 extends PvApplication
{
public $ZonePrinc ;
protected function ChargeIHMs()
{
// Inscrire la zone web de l’Application
$this->ZonePrinc = $this->InsereIHM("zonePrinc", new ZoneWebApplication1()) ;
}
}
// Déclaration de la zone web
class ZoneWebApplication1 extends PvZoneWebSimple
{
// Afficher la zone web en fonction du chemin dans le navigateur
public $AccepterTousChemins = 1 ;
public $ScriptAccueil ;
public $EncodageDocument = 'utf-8' ;
public $MotsCleMeta = 'Attributs, Zone, Web Simple' ;
public $DescriptionMeta = 'Description d\'une Zone Web Simple' ;
protected function ChargeScripts()
{
// Inscrire le script web par défaut
$this->ScriptAccueil = $this->InsereScriptParDefaut(new ScriptAccueilApplication1()) ;
}
}
// Déclaration du script web par défaut.
class ScriptAccueilApplication1 extends PvScriptWebSimple
{
// Code HTML qui sera affiché dans le navigateur
public function RenduSpecifique()
{
$ctn = '' ;
$ctn = "BIENVENUE SUR MA APPLICATION 1" ;
return $ctn ;
}
}
$app = new MonApplication1() ;
$app->Execute() ;
?>

=== Bibliothèques CSS et Javascript

La zone web simple inclut automatiquement les scripts & styles CSS des librairies Javascript populaires.

[cols=",,",options="header",]
|===============================================================================================================
|*Librairie* |*Propriété* |*Spécification*
|*jQuery* |$InclureJQuery |Mettre à 1 pour inclure la librairie jquery
| |$CheminJQuery |Chemin relatif du fichier Js jQuery. Par défaut : "js/jquery.min.js"
| |$InclureJQueryMigrate |Mettre à 1 pour inclure la librairie jquery-migrate
| |$CheminJQueryMigrate |Chemin relatif du fichier Js JQueryMigrate. Par défaut : "js/jquery-migrate.min.js"
|*jQueryUi* |$InclureJQueryUi |Mettre à 1 pour inclure la librairie jqueryui
| |$CheminJsJQueryUi |Chemin relatif du fichier Js JQuery Ui. Par défaut : "js/jquery-ui.min.js"
| |$CheminCSSJQueryUi |Chemin relatif du fichier CSS jQuery Ui. Par défaut : "css/jquery-ui.css"
|*Bootstrap* |$InclureBootstrap |Mettre à 1 pour inclure la librairie bootstrap
| |$CheminJsBootstrap |Chemin relatif du fichier Js Bootstrap. Par défaut : "js/bootstrap.min.js"
| |$CheminCSSBootstrap |Chemin relatif du fichier CSS Bootstrap. Par défaut : "css/bootstrap.css"
| |$InclureBootstrapTheme |Mettre à 1 pour inclure un thème personnalisé Bootstrap
| |$CheminCSSBootstrapTheme |Chemin relatif du fichier CSS Bootstrap. Par défaut : "css/bootstrap-theme.min.css"
| |$InclureFontAwesome |Mettre à 1 pour inclure Font Awesome
| |$CheminFontAwesome |Chemin relatif du fichier CSS Font Awesome. Par défaut : "css/font-awesome.css"
|===============================================================================================================

=== Contenus CSS et Javascript

La zone a également des méthodes pour insérer du contenu CSS et JS.

[cols=",",options="header",]
|================================================================================================================
|*Méthode* |*Description*
|InscritContenuCSS ($contenu) |Insère un tag <style> avec le $contenu
|InscritLienCSS ($href) |Insère un tag <link rel="stylesheet" type="text/css" href="$href" />
|InscritContenuJs ($contenu) |Insère un tag <script> avec le $contenu
|InscritContenuJsCmpIE ($contenu, $versionMin=9) |Insère un tag <script> avec le $contenu, avec les directives IE
|InscritLienJs ($src) |Insère un tag <script> avec la source $src
|InscritLienJsCmpIE ($src, $versionMin=9) |Insère un tag <script> avec la source $src, avec les directives IE
|================================================================================================================

Veuillez réécrire la méthode InclutLibrairiesExternes(), en invoquant la méthode parente.

[source,php]
class MaZone1 extends PvZoneWebSimple
{
Protected function InclutLibrairiesExternes()
{
Parent::InclutLibrairiesExternes() ;
// Inscrire les autres librairies JS & CSS…
$this->InscritContenuCSS("body \{ text-align:center ; }") ;
}
}

=== Scripts

La zone web contient des scripts, qui renvoient un contenu spécifique en fonction d’un paramètre GET (appelleScript par défaut).

Les scripts varient le contenu d’une zone, tout en gardant les mêmes entêtes et pieds de document HTML.

=== Membership

==== Fonctionnement

Le Membership est le service d’authentification dans la zone.

Il se base sur les modèles relationnels suivants :

Sans Support LDAP :

image:extracted-media/media/image3.png[image,width=349,height=161]

Avec Support LDAP :

image:extracted-media/media/image4.png[image,width=380,height=200]

Pour l’installer, vous devez créer une base de données et les tables nécessaires.

Vous trouverez les scripts SQL dans le code source :

[cols=",",options="header",]
|===========================================================================================================
|*Fichier* |*Description*
|install-membership-pv-mysql.sql |Tables de membership pour MySQL
|install-membership-pv-mysql-ad.sql |Tables de membership pour MySQL, avec authentification Active Directory
|install-membership-pv-orcl.sql |Tables de membership pour Oracle
|install-membership-pv-orcl-ad.sql |Tables de membership pour Oracle, avec authentification Active Directory
|===========================================================================================================

==== Déclaration

Tout service d’authentification doit hériter de la classe *AkSqlMembership*.

[source,php]
// 1. Déclarer la base de données
class MaBD extends MysqlDB
{
}
// 2. Déclarer le Membership
class MonMembership extends AkSqlMembership
{
protected function InitConfig(& $parent)
{
parent::InitConfig($parent) ;
// Affecter la base de données du Membership
$this->Database = new MaBD() ;
}
}
class MaZone1 extends PvZoneWebSimple
{
// ...
// 3. Affecter le membership à la Zone
Public $NomClasseMembership = "MonMembership" ;
}

==== Propriétés et méthodes principales

[cols=",",options="header",]
|=========================================================================================
|*Propriété/Méthode* |*Description*
|$Database |Base de données qui contient les tables de membership. Type accepté : CommonDB
|$RootMemberId |ID Membre du super administrateur
|$GuestMemberId |ID Membre de l’invité
|$MemberTable |Nom de la table des membres dans la base de données
|$ProfileTable |Nom de la table des profils dans la base de données
|$RoleTable |Nom de la table des rôles dans la base de données
|$PrivilegeTable |Nom de la table des privilèges dans la base de données
|$SessionSource |Source de la session : +
SESSION : variable $_SESSION +
COOKIE : variable $_COOKIES
|$SessionMemberKey |Clé de la session PHP ($_SESSION) qui contient l’ID du membre connecté
|LogonMember($memberId) |Connecte l’ID du Membre dans la session
|LogoutMember($memberId) |Déconnecte l’ID du Membre dans la session
|ValidateConnection($login, $password) |Vérifie si les accès du membre sont corrects
|=========================================================================================

==== Scripts web Membership

Lorsque vous déclarez un membership dans la zone web, la zone crée automatiquement des scripts.

[cols=",,,",options="header",]
|===============================================================================================================================================
|*Nom du script* |*Classe script web* |*Pré-requis +
zone web* |*Description*
|connexion |PvScriptConnexionWeb |Aucun |Page de connexion
|deconnexion |PvScriptDeconnexionWeb |Aucun |Page de déconnexion
|recouvreMP |PvScriptRecouvreMPWeb |Aucun |Page pour récupérer son mot de passe, à partir du login et du mot de passe
|inscription |PvScriptInscriptionWeb |Mettre la propriété $AutoriserInscription à 1 |Page d’inscription d’un membre
|modifPrefs |PvScriptModifPrefsWeb |Mettre la propriété $AutoriserModifPrefs à 1 |Page pour modifier les informations du membre (nom, prénom, …)
|doitChangerMotPasse |PvScriptDoitChangerMotPasseWeb |Aucun |Page qui force le membre connecté à changer son mot de passe
|changeMotPasse |PvScriptChangeMotPasseWeb |Aucun |Page pour modifier le mot de passe
|ajoutMembre |PvScriptAjoutMembreMSWeb |Aucun |Ajouter un membre
|importMembre |PvScriptImportMembreMSWeb |Aucun |Importe des membres à partir d’un fichier CSV
|modifMembre |PvScriptModifMembreMSWeb |Aucun |Modifie un membre
|supprMembre |PvScriptSupprMembreMSWeb |Aucun |Désactive le membre
|listeMembres |PvScriptListeMembresMSWeb |Aucun |Liste les membres
|ajoutProfil |PvScriptAjoutProfilMSWeb |Aucun |Ajoute un profil
|modifProfil |PvScriptModifProfilMSWeb |Aucun |Modifie un profil
|supprProfil |PvScriptSupprProfilMSWeb |Aucun |Désactive le profil
|listeProfils |PvScriptListeProfilsMSWeb |Aucun |Liste les profils
|ajoutRole |PvScriptAjoutRoleMSWeb |Aucun |Ajoute un rôle
|modifRole |PvScriptModifRoleMSWeb |Aucun |Modifie un rôle
|supprRole |PvScriptSupprRoleMSWeb |Aucun |Désactive un rôle
|listeRoles |PvScriptListeRolesMSWeb |Aucun |Liste les rôles
|ajoutServeurAD |PvScriptAjoutServeurADWeb |Aucun |Ajoute une connexion LDAP
|modifServeurAD |PvScriptModifServeurADWeb |Aucun |Modifie une connexion LDAP
|supprServeurAD |PvScriptSupprServeurADWeb |Aucun |Supprime une connexion LDAP
|listeServeursAD |PvScriptListeServeursADWeb |Aucun |Liste les connexions LDAP
|===============================================================================================================================================

Vous pouvez personnaliser chacun de ces scripts quand vous déclarez la zone web.

[source,php]
class MaZoneWeb1 extends PvZoneWebSimple
{
// Cas du script connexion
public $NomScriptConnexion = "connecter" ;
public $NomClasseScriptConnexion = "MonScriptConnexion" ;
// ...
}
class MonScriptConnexion extends PvScriptConnexionWeb
{
}

==== Le remplisseur de config Membership

La zone, pour remplir chaque script de membership, utilise sa propriété *$ NomClasseRemplisseurConfigMembership*.

C’est un objet qui hérite de la classe *PvRemplisseurConfigMembership*.

[source,php]
class MaZoneWeb1 extends PvZoneWebSimple
{
public $NomClasseRemplisseurConfigMembership = "MonRemplCfgMembership" ;
// ...
}
class MonRemplCfgMembership extends PvRemplisseurConfigMembership
{
}

Pour le personnaliser, veuillez créer une classe héritant de celle-ci et réécrivez les méthodes suivantes.

[cols=",",options="header",]
|===================================================================================================================
|*Propriété / Méthode* |*Description*
|RemplitFormulaireGlobalProfil(& $form) |S’applique à n’importe quel formulaire de profil
|RemplitFormulaireGlobalRole(& $form) |S’applique à n’importe quel formulaire de rôle
|RemplitFiltresEditionFormMembre(& $form) |Assigne les filtres d’édition à n’importe quel formulaire de membre.
|InitFormulaireRole(& $form) |Initialise n’importe quel formulaire de rôle.
|InitFormulaireProfil(& $form) |Initialise n’importe quel formulaire de profil.
|InitFormulaireMembre(& $form) |Initialise n’importe quel formulaire de membre.
|RemplitFiltresMPFormMembre(& $form) |Assigne les filtres sur n’importe quel formulaire de mot de passe
|RemplitFormulaireGlobalMembre(& $form) |Définit les caractéristiques de n’importe quel formulaire de profil
|RemplitFormulaireInfosMembre(& $form) |Définit les caractéristiques de n’importe quel formulaire de membre
|RemplitFormulaireChangeMPMembre(& $form) |Définit les caractéristiques de n’importe quel formulaire de mot de passe
|InitTableauMembre(& $table) |Initialise le tableau de données des membres
|InitTableauProfil(& $table) |Initialise le tableau de données des profils
|InitTableauRole(& $table) |Initialise le tableau de données des rôles
|RemplitFiltresTableauMembre(& $table) |Assigne les filtres du tableau de données des membres
|RemplitDefinitionsColonneTableauMembre(& $table) |Assigne les colonnes de tableau de données des membres
|RemplitDefinitionColActionsTableauMembre(& $table) |Assigne les actions du tableau de données des membres
|RemplitFiltresTableauRole(& $table) |Assigne les filtres du tableau de données des rôles
|RemplitDefinitionsColonneTableauRole(& $table) |Assigne les colonnes de tableau de données des rôles
|RemplitDefinitionColActionsTableauRole(& $table) |Assigne les actions du tableau de données des rôles
|RemplitFiltresTableauProfil(& $table) |Assigne les filtres du tableau de données des profils
|RemplitDefinitionsColonneTableauProfil(& $table) |Assigne les colonnes de tableau de données des profils
|RemplitDefinitionColActionsTableauProfil(& $table) |Assigne les actions du tableau de données des profils
|===================================================================================================================

=== Documents Web

Un document web personnalise l’affichage complet de chaque script.

Dans la zone, il est utile :

* pour les scripts à imprimer
* pour les scripts qui s’afficheront dans une boîte de dialogue

==== Déclaration

Chaque document web hérite de la classe *PvDocumentWebHtml*.

Veuillez réecrire les méthodes *PrepareRendu(& $zone)*, *RenduEntete(& $zone)* et *RenduPied(& $zone)*.

Vous pouvez manipuler le script sélectionné avec *$zone->ScriptPourRendu*

[source,php]
class MonDocumentWeb1 extends PvDocumentWebHtml
{
public function PrepareRendu(& $zone)
{
// Inclure des libraires Javascript & CSS spécifiques au document
}
public function RenduEntete(& $zone)
{
return parent::RenduEntete($zone) ;
}
public function RenduPied(& $zone)
{
return parent::RenduPied($zone) ;
}
}

==== Intégration dans la zone web

D’abord, vous devez mettre la propriété *UtiliserDocumentWeb* à 1.

Ensuite, déclarez chaque document dans la méthode *ChargeConfig()* de la zone web.

[source,php]
class MaZoneWeb extends PvZoneWebSimple
{
public $UtiliserDocumentWeb = 1 ;
public function ChargeConfig()
{
Parent::ChargeConfig() ;
$this->DocumentsWeb["defaut"] = new MonDocumentWeb1() ;
$this->DocumentsWeb["impression"] = new MonDocumentWeb2() ;
}
}

Le 1^er^ document web déclaré sera utilisé par défaut pour tous les scripts. Dans le cas ci-dessus, c’est le document web « defaut ».

==== Affectation à un script

Pour définir le document web du script, renseignez la propriété *NomDocumentWeb* du script.

[source,php]
class MonScriptWeb3 extends PvScriptWebSimple
{
// …
public $NomDocumentWeb = "impression" ;
// …
}

=== Composants IU

Les composants IU permettent d’interagir avec les utilisateurs.

==== Utilisation

Vous devez suivre ce procédé :

[arabic]
. Initier le composant

[source,php]
$comp = new PvFormulaireDonnesHtml() ;

[arabic, start=2]
. Renseigner ses propriétés d’initiation, s’il en possède

[source,php]
$comp->InscrireCommandeExecuter = 1 ;

[arabic, start=3]
. Adoptez le script ou la zone contexte par les méthodes *AdopteScript($nom, & $script)* ou *AdopteZone($nom, $zone)*.

[source,php]
$comp->AdopteScript("monComposant", $this) ;

[arabic, start=4]
. Charger la configuration du composant par la méthode *ChargeConfig()*

[source,php]
$comp->ChargeConfig() ;

[arabic, start=5]
. Renseigner ses autres propriétés

[source,php]
$comp->CommandeExecuter->Libelle = "VALIDER" ;
$comp->SuccesMessageExecution = "La page a été modifiée" ;

[arabic, start=6]
. Invoquer le Rendu du composant par la méthode *RenduDispositif()*

[source,php]
$ctn = $comp->RenduDispositif() ;

==== Définition

Vous devez déclarer les composants IU dans la zone web, le document web ou le script web.

Pour le définir (étape 1. à 5 de l’utilisation), utilisez ces méthodes :

[cols=",,",options="header",]
|=============================================================================================================================
|*Classe* |*Méthode* |*Directives*
|Document Web |PrepareRendu(& $zone) |Aucun
|Zone Web |DetermineEnvironnement(& $script) |Invoquer parent::DetermineEnvironnement($script) après avoir défini le composant
|Script Web |DetermineEnvironnement() |Aucun
|=============================================================================================================================

Vous invoquez le rendu séparément :

[cols=",,",options="header",]
|=====================================================================================================
|*Classe* |*Méthode* |*Directives*
|Document Web |RenduEntete(& $zone) |Invoquer *parent::RenduEntete($zone)* avant le rendu du composant
| |RenduPied(& $zone) |Invoquer *parent::RenduEntete ($zone)* après le rendu du composant
|Zone Web |RenduContenuCorpsDocument () |Aucun
|Script Web |*protected* RenduDispositifBrut() |Aucun
| |RenduSpecifique() |Aucun
|=====================================================================================================

==== Types de composant

Plusieurs composants existent, dont les principaux sont :

[cols=",,",options="header",]
|======================================================================================================
|*Nom* |*Classe* |*Rôle*
|*Données* | |
|Tableau de données Html |PvTableauDonneesHtml |Affiche sous forme de tableau des données
|Grille de données Html |PvGrilleDonneesHtml |Affiche sous forme de grille des données
|Formulaire de données Html |PvFormulaireDonneesHtml |Affiche sous forme de formulaire de données
|*Graphiques & Statistiques* | |
|Chart pChart |PvPChart |Chart réalisée avec la librairie PHP pChart 2.0
|*Sliders* | |
|Slider JQuery Camera |PvJQueryCamera |Slider réalisé à partir de la librairie Javascript jQuery Camera
|======================================================================================================

=== Actions Web

==== Définition

Une Action Web est un ensemble d’instructions s’exécute dans la Zone Web. Elle ne se limite pas d’afficher un contenu HTML, comme les scripts web.

Elle peut également :

* déclencher le téléchargement d’un fichier
* renvoyer un fichier RSS, JS ou CSS
* renvoyer une réponse JSON
* exécuter un code précis, avant d’afficher le script web

==== Déclaration

La zone web exécute une action web à partir du paramètre GET *appelleAction*.

Vous pouvez déclarer les actions dans plusieurs méthodes :

[cols=",,,",options="header",]
|========================================================================================================================================================================================================================================================
|*Objet* |*Méthode* |*Contexte* |*Description*
|Zone web |InsereActionPrinc($nom, $action) |Utiliser dans la méthode *ChargeConfig()* |Les actions principales s’exécutent avant d’exécuter le script en cours
| |InsereActionAvantRendu($nom, $action) |Utiliser dans la méthode *ChargeConfig()* |S’exécutent avant d’afficher le script en cours
|Script web |InsereActionAvantRendu($nom, $action) |Utiliser dans la méthode *DetermineEnvironnement()* |Déclare l’action uniquement lorsque le script doit être affiché. Le nom de l’action sera basé sur l’ID Instance du script et le nom de l’action.
|========================================================================================================================================================================================================================================================

==== Types d’action

[cols=",,",options="header",]
|==================================================================================================================================================================================================================================
|*Classe* |*Description* |*Utilisation*
|PvActionBaseZoneWebSimple |Classe de base |Réécrire la méthode *Execute()*
|PvActionNotificationWeb |Exécute des instructions et garde le résultat (succès/echec et message d’exécution) a|
* Réécrire la méthode *Execute()*. A l’intérieur, utiliser ces méthodes pour définir le résultat : +
- *ConfirmeSucces($msg)* +
- *RenseigneErreur($msg*)

* Dans le script ou la zone, utilisez la propriété *TypeErreur* et méthode *ObtientMessage()* de l’instance Action pour afficher le résultat. Pour tester si l’action a ramené un résultat, utilisez la méthode *PossedeMessage() *

a|
PvActionResultatJSONZoneWeb

PvActionEnvoiJSON

|Affiche un contenu JSON dans le navigateur |Réécrire la méthode *Execute()*. A l’intérieur, définissez la propriété *Resultat*. Cette propriété sera le retour JSON.
|PvActionTelechargFichier |Démarre le téléchargement du fichier |Réécrire la méthode *Execute()*. A l’intérieur : +
- Renseignez la propriété *NomFichierAttache* pour définir le nom du fichier téléchargé. Utilisez la fonction *echo* pour envoyer le contenu du fichier +
- Si le fichier existe déjà, utilisez *CheminFichierSource* pour le charger.
|==================================================================================================================================================================================================================================

=== Tâches Web

==== Définition

Une tâche web est une tâche planifiée, qui exécute des instructions.

La tâche démarre automatiquement quand vous affichez n’importe script de la zone web, une fois son délai d’attente dépassé.

Elle s’exécute dans un autre processus http que celui du script.

==== Déclaration

Veuillez créer votre tâche à partir de la classe *PvTacheWebBaseSimple*. Définissez la propriété « *DelaiExecution* » (en heure) et réécrivez la méthode *ExecuteInstructions()*.

[source,php]
class MaTacheWeb1 extends PvTacheWebBaseSimple
{
public $DelaiExecution = 0.05 ; // S’exécute après 180 secondes
protected function ExecuteInstructions()
{
Echo "OK, ma tache est executee" ;
}
}

Les membres utiles dans la méthode *ExecuteInstructions()* sont :

* *ApplicationParent* : Renvoie l’Application
* *ZoneParent* : Renvoie la zone contenant la tâche web

==== Le gestionnaire de tâches web

La zone web possède un gestionnaire de tâches web, dont les rôles sont :

* Contenir les tâches web
* Définir l’emplacement de sauvegardes des états de chaque tâche (en cours, terminé, date d’exécution, …)

Pour personnaliser le gestionnaire de tâches web, veuillez réécrire la méthode *ChargeGestTachesWeb()*.

La propriété *GestTachesWeb* représente le gestionnaire de tâches. Ses membres et méthodes utiles sont :

[cols=",",options="header",]
|=============================================================================================================================================
|*Propriété/Méthode* |*Description*
|*NomDossierTaches* |Chemin du répertoire contenant l’état de chaque tâche web. Le chemin est relatif au chemin du fichier PHP de la zone web.
|*InsereTacheWeb($nom, $tache)* |Inscrit la tâche programmée dans la zone web
|=============================================================================================================================================

[source,php]
class MaZoneWeb1 extends PvZoneWebSimple
{
// ...
protected function ChargeGestTachesWeb()
{
$this->GestTachesWeb->NomDossierTaches = "taches/data" ;
$this->InsereTacheWeb('tache1', new MaTacheWeb1()) ;
}
}

==== Le fichier Etat de la tâche web

L’état de la tâche est sauvegardé dans le fichier de ce format :

<NomDossierTaches-du-GestTachesWeb>/<IDInstanceCalc-tache-web>.dat

Si vous supprimez ce fichier, la tâche web sera exécutée au prochain affichage de la zone web.

=== Le Formulaire de Données

==== Présentation

Le formulaire de données est un composant IU.

Il affiche :

* Un message d’exécution :
* Un formulaire de filtres : Il contiendra des champs qui seront soumis par la méthode « POST ».
* Un bloc de commandes : Il contiendra des boutons, qui recevront les valeurs du formulaire

La classe du formulaire de données est *PvFormulaireDonneesHtml*.

==== Utilisation basique

Voici un exemple d’utilisation.

[source,php]
class MonScript2 extends PvScriptWebSimple
{
public $Form1 ;
public $Flt1 ;
public $Flt2 ;
public function DetermineEnvironnement()
{
// Initiation
$this->Form1 = new PvFormulaireDonneesHtml() ;
// Toujours afficher le formulaire
$this->Form1->InclureElementEnCours = 0 ;
$this->Form1->InclureTotalElements = 0 ;
// Définir la classe commande "Executer"
$this->Form1->NomClasseCommandeExecuter = "MaCmdExecScript2" ;
// Liaison avec le script en cours
$this->Form1->AdopteScript("form1", $this) ;
// Chargement de la config
$this->Form1->ChargeConfig() ;
// Définition des autres propriétés
$this->Flt1 = $this->Form1->InsereFltEditHttpPost("champ1") ;
$this->Flt1->Libelle = "Champ 1" ;
$this->Flt2 = $this->Form1->InsereFltEditHttpPost("champ2") ;
$this->Flt2->Libelle = "Champ 2" ;
}

public function RenduSpecifique()
{
$ctn = '' ;
// Rendu du formulaire de donnees
$ctn .= $this->Form1->RenduDispositif() ;
return $ctn ;
}
}

class *MaCmdExecScript2* extends PvCommandeExecuterBase
{
protected function ExecuteInstructions()
{
$this->ConfirmeSucces("Commande exécutée avec succès") ;
}
}

==== Interaction avec base de données

Vous pouvez manipuler les bases de données avec son fournisseur de données.

===== Ajout d’enregistrement

[source,php]
class MonScript2 extends PvScriptWebSimple
{
public function DetermineEnvironnement()
{
// Initiation
$this->Form1 = new PvFormulaireDonneesHtml() ;
// Toujours afficher le formulaire
$this->Form1->InclureElementEnCours = 0 ;
$this->Form1->InclureTotalElements = 0 ;
// Définir la classe commande "Executer"
$this->Form1->NomClasseCommandeExecuter = "PvCommandeAjoutElement" ;
// Liaison avec le script en cours
$this->Form1->AdopteScript("form1", $this) ;
// Chargement de la config
$this->Form1->ChargeConfig() ;
// Définition des autres propriétés
$this->Flt1 = $this->Form1->InsereFltEditHttpPost("colonne1", "colonne1") ;
$this->Flt1->Libelle = "Colonne 1" ;
$this->Flt2 = $this->Form1->InsereFltEditHttpPost("colonne2", "colonne2") ;
$this->Flt2->Libelle = "Colonne 2" ;
// Définition du fournisseur de données
$this->FournisseurDonnees = new PvFournisseurDonneesSql() ;
$this->FournisseurDonnees->BaseDonnees = new MaBD() ;
$this->FournisseurDonnees->RequeteSelection = "matable1" ;
$this->FournisseurDonnees->TableEdition = "matable1" ;
}
// ...
}
===== Modification d’enregistrement

[source,php]
class MonScript2 extends PvScriptWebSimple
{
public function DetermineEnvironnement()
{
// Initiation
$this->Form1 = new PvFormulaireDonneesHtml() ;
// Afficher le formulaire s’il y a un enregistrement
$this->Form1->InclureElementEnCours = 1 ;
$this->Form1->InclureTotalElements = 1 ;
// Définir la classe commande "Executer"
$this->Form1->NomClasseCommandeExecuter = "PvCommandeModifElement" ;
// Liaison avec le script en cours
$this->Form1->AdopteScript("form1", $this) ;
// Chargement de la config
$this->Form1->ChargeConfig() ;
// Définition des filtres de sélection
$this->Cle1 = $this->Form1->InsereFltSelectHttpGet("macle1", "cle1 = <self>") ;
// Définition des autres propriétés
$this->Flt1 = $this->Form1->InsereFltEditHttpPost("colonne1", "colonne1") ;
$this->Flt1->Libelle = "Colonne 1" ;
$this->Flt2 = $this->Form1->InsereFltEditHttpPost("colonne2", "colonne2") ;
$this->Flt2->Libelle = "Colonne 2" ;
// Définition du fournisseur de données
$this->FournisseurDonnees = new PvFournisseurDonneesSql() ;
$this->FournisseurDonnees->BaseDonnees = new MaBD() ;
$this->FournisseurDonnees->RequeteSelection = "matable1" ;
$this->FournisseurDonnees->TableEdition = "matable1" ;
}
// ...
}

===== Suppression d’enregistrement

[source,php]
class MonScript2 extends PvScriptWebSimple
{
public function DetermineEnvironnement()
{
// Initiation
$this->Form1 = new PvFormulaireDonneesHtml() ;
// Afficher le formulaire s’il y a un enregistrement
$this->Form1->InclureElementEnCours = 1 ;
$this->Form1->InclureTotalElements = 1 ;
// Empêcher l’édition des filtres
$this->Form1->Editable = 0 ;
// Définir la classe commande "Executer"
$this->Form1->NomClasseCommandeExecuter = "PvCommandeSupprElement" ;
// Liaison avec le script en cours
$this->Form1->AdopteScript("form1", $this) ;
// Chargement de la config
$this->Form1->ChargeConfig() ;
// Définition des filtres de sélection
$this->Cle1 = $this->Form1->InsereFltSelectHttpGet("macle1", "cle1 = <self>") ;
// Définition des autres propriétés
$this->Flt1 = $this->Form1->InsereFltEditHttpPost("colonne1", "colonne1") ;
$this->Flt1->Libelle = "Colonne 1" ;
$this->Flt2 = $this->Form1->InsereFltEditHttpPost("colonne2", "colonne2") ;
$this->Flt2->Libelle = "Colonne 2" ;
// Définition du fournisseur de données
$this->FournisseurDonnees = new PvFournisseurDonneesSql() ;
$this->FournisseurDonnees->BaseDonnees = new MaBD() ;
$this->FournisseurDonnees->RequeteSelection = "matable1" ;
$this->FournisseurDonnees->TableEdition = "matable1" ;
}
// ...
}

==== Propriétés d’initiation

[cols=",",options="header",]
|======================================================================================================================
|*Propriété* |*Description*
|$InclureElementEnCours |Le formulaire sera disponible si le fournisseur de données contient au moins un enregistrement
|$InclureTotalElement |Comptera le nombre d’enregistrement du fournisseur de données.
|$InscrireCommandeExecuter |Crée une commande « Exécuter » au chargement de config du composant
|$LibelleCommandeExecuter |Libellé de la commande « Exécuter »
|$NomClasseCommandeExecuter |Nom de la classe commande « Exécuter »
|$InscrireCommandeAnnuler |Crée une commande « Annuler » au chargement de config du composant
|$LibelleCommandeAnnuler |Libellé de la commande « Annuler »
|$NomClasseCommandeAnnuler |Nom de la classe commande « Annuler »
|======================================================================================================================

==== Filtres de sélection

[cols=",",options="header",]
|=========================================================================================================================================================================================================
|*Méthode* |*Description*
|InsereFltLgSelectHttpGet($nom, $exprDonnees='', $nomClsComp='') |Ajoute un filtre http GET
|InsereFltLgSelectHttpPost($nom, $exprDonnees='', $nomClsComp='') |Ajoute un filtre http POST
|InsereFltLgSelectHttpUpload($nom, $cheminDossierDest="", $exprDonnees='', $nomClsComp='') |Ajoute un filtre http UPLOAD. Tous les fichiers téléchargés seront déposés dans le dossier $cheminDossierDest.
|InsereFltLgSelectSession($nom, $exprDonnees='', $nomClsComp='') |Ajoute un filtre contenant la valeur d’une session
|InsereFltLgSelectFixe($nom, $valeur, $exprDonnees='', $nomClsComp='') |Ajoute un filtre basé sur une valeur fixe
|InsereFltLgSelectCookie($nom, $exprDonnees='', $nomClsComp='') |Ajoute un filtre contenant la valeur d’un cookie
|=========================================================================================================================================================================================================

==== Filtres d’édition

[cols=",",options="header",]
|================================================================================================================================================================================================
|*Méthode* |*Description*
|InsereFltEditHttpGet($nom, $colLiee='', $nomClsComp='') |Ajoute un filtre http GET
|InsereFltEditHttpPost($nom, $colLiee='', $nomClsComp='') |Ajoute un filtre http POST
|InsereFltEditHttpUpload($nom, $cheminDossierDest="", $colLiee='', $nomClsComp='') |Ajoute un filtre http UPLOAD. Tous les fichiers téléchargés seront déposés dans le dossier $cheminDossierDest
|InsereFltEditSession($nom, $colLiee='', $nomClsComp='') |Ajoute un filtre contenant la valeur d’une session
|InsereFltEditFixe($nom, $valeur, $colLiee='', $nomClsComp='') |Ajoute un filtre basé sur une valeur fixe
|InsereFltEditCookie($nom, $colLiee='', $nomClsComp='') |Ajoute un filtre contenant la valeur d’un cookie
|================================================================================================================================================================================================

==== Autres propriétés

[cols=",",options="header",]
|=============================================================================================================================
|*Propriété / Méthode* |*Description*
|$CacherBlocCommandes |N’affiche pas le bloc de commandes
|$CacherFormulaireFiltres |N’affiche pas le formulaire des filtres
|$MessageAucunElement |Message à afficher si le formulaire ne trouve pas d’élément
|$CacherFormulaireFiltresApresCmd |Cache le formulaire de filtres si une commande est exécutée
|$Largeur |Largeur du formulaire
|$ElementsEnCours |Lignes retournées après le rendu
|$ElementEnCours |1^ère^ Ligne retournée après le rendu
|RedirigeCmdAnnulerVersUrl($url) |Redirige la page vers l’URL lorsque vous cliquerez sur le bouton « Annuler » du formulaire
|RedirigeCmdExecuterVersUrl($url) |Redirige la page vers l’URL lorsque vous cliquerez sur le bouton « Executer » du formulaire
|FigeFiltresEdition() |Fixe tous les filtres édition en lecture seule
|CacheFiltresEdition() |Cache tous les filtres édition
|DoitInclureElement() |Confirme si les propriétés $InclureElementEnCours & $InclureTotalElements sont vraies.
|AnnuleLiaisonParametres() |Interdit les filtres d’édition de récupérer les valeurs de leurs paramètres.
|=============================================================================================================================

==== Commandes

[cols=",,",options="header",]
|=====================================================================================================================================================================================================
|*Classe* |*Prérequis* |*Description*
|PvCommandeAnnulerBase |Aucun |Commande pour annuler l’édition du formulaire de données
|PvCommandeExecuterBase |Aucun |Commande pour exécuter le formulaire de données. Veuillez étendre cette classe.
|PvCommandeAjoutElement |Les propriétés InclureElementEnCours & InclureTotalElements doivent avoir la valeur 0 |Commande pour insérer un enregistrement dans le fournisseur de données du formulaire
|PvCommandeModifElement |Les propriétés InclureElementEnCours & InclureTotalElements doivent avoir la valeur 1 |Commande pour modifier un enregistrement dans le fournisseur de données du formulaire
|PvCommandeSupprElement |Les propriétés InclureElementEnCours & InclureTotalElements doivent avoir la valeur 1 |Commande pour supprimer un enregistrement dans le fournisseur de données du formulaire
|=====================================================================================================================================================================================================

==== Rendu du formulaire de filtres

Vous pouvez personnaliser le rendu du formulaire de filtres avec sa propriété *$DessinateurFiltresEdition*.

Veuillez créer une classe héritant de *PvDessinFiltresDonneesHtml* et réécrire sa méthode publique *Execute(& $script, & $composant, $parametres)*.

Vous avez 2 méthodes dans la nouvelle classe, pour chaque filtre de données :

* *RenduLibelleFiltre(& $filtre)* pour le libellé du filtre de données
* *RenduFiltre(& $filtre, & $composant)* pour le composant du filtre de données

[source,php]
class MonScript1 extends PvScriptWebSimple
{
public $Form1 ;
public $Flt1 ;
public $Flt2 ;
public function DetermineEnvironnement()
{
// Initiation
$this->Form1 = new PvFormulaireDonneesHtml() ;
// Toujours afficher le formulaire
$this->Form1->InclureElementEnCours = 0 ;
$this->Form1->InclureTotalElements = 0 ;
// Definir le dessinateur de filtres edition
$this->Form1->DessinateurFiltresEdition = new MonDessinFiltresDonnees() ;
// Liaison avec le script en cours
$this->Form1->AdopteScript("form1", $this) ;
// Chargement de la config
$this->Form1->ChargeConfig() ;
// Définition des autres propriétés
$this->Flt1 = $this->Form1->InsereFltEditHttpPost("champ1") ;
$this->Flt1->Libelle = "Champ 1" ;
$this->Flt2 = $this->Form1->InsereFltEditHttpPost("champ2") ;
$this->Flt2->Libelle = "Champ 2" ;
}
// ...
public function RenduSpecifique()
{
$ctn = '' ;
// Rendu du formulaire de donnees
$ctn .= $this->Form1->RenduDispositif() ;
return $ctn ;
}
}
class MonDessinFiltresDonnees extends PvDessinFiltresDonneesHtml
{
public function Execute(& $script, & $composant, $parametres)
{
$ctn = '' ;
$ctn .= '<p><b>'.$this->RenduLibelleFiltre($script->Flt1).'<b><br>' ;
$ctn .= $this->RenduFiltre($script->Flt1, $composant).'</p>' ;
$ctn .= '<hr>' ;
$ctn .= '<p><b>'.$this->RenduLibelleFiltre($script->Flt2).'<b><br>' ;
$ctn .= $this->RenduFiltre($script->Flt2, $composant).'</p>' ;
return $ctn ;
}
}

==== Rendu du bloc de commandes

Pour personnaliser le rendu du bloc des commandes, utilisez la propriété *$DessinateurBlocCommandes*.

Veuillez créer une classe héritant de *PvDessinCommandesHtml* et réécrire sa méthode publique *Execute(& $script, & $composant, $parametres)*.

Cette nouvelle classe donne le rendu d’une commande avec la méthode *RenduCommande(& $commande)*.

[source,php]
class MonScript1 extends PvScriptWebSimple
{
public $Form1 ;
public $Flt1 ;
public $Flt2 ;
public function DetermineEnvironnement()
{
// Initiation
$this->Form1 = new PvFormulaireDonneesHtml() ;
// Toujours afficher le formulaire
$this->Form1->InclureElementEnCours = 0 ;
$this->Form1->InclureTotalElements = 0 ;
// Definir le dessinateur de commandes
$this->Form1->DessinateurBlocCommandes = new MonDessinCommandes() ;
// Liaison avec le script en cours
$this->Form1->AdopteScript("form1", $this) ;
// Chargement de la config
$this->Form1->ChargeConfig() ;
// Définition des autres propriétés
$this->Flt1 = $this->Form1->InsereFltEditHttpPost("champ1") ;
$this->Flt1->Libelle = "Champ 1" ;
$this->Flt2 = $this->Form1->InsereFltEditHttpPost("champ2") ;
$this->Flt2->Libelle = "Champ 2" ;
// Commandes
// ...
}
public function RenduSpecifique()
{
$ctn = '' ;
// Rendu du formulaire de donnees
$ctn .= $this->Form1->RenduDispositif() ;
return $ctn ;
}
}
// Declarer le dessinateur de commandes
class MonDessinCommandes extends PvDessinCommandesHtml
{
public function Execute(& $script, & $composant, $parametres)
{
$ctn = '' ;
$ctn .= '<p>' ;
// Le formulaire est dans la variable $composant
$ctn .= $this->RenduCommande($composant->CommandeAnnuler) ;
$ctn .= '<hr />' ;
$ctn .= $this->RenduCommande($composant->CommandeExecuter) ;
$ctn .= '</p>' ;
return $ctn ;
}
}

=== Le Tableau de Données

==== Présentation

Le tableau de données est un composant IU. Il affiche :

* Un formulaire de champs pour filtrer les résultats
* Un bloc de commandes, pour l’exportation des résultats à un format précis…
* Un tableau des résultats de la recherche

La classe de ce composant est *PvTableauDonnesHtml*.

==== Utilisation basique

Il utilise toujours un fournisseur de données pour le rendu.

[source,php]
class MonScript1 extends PvScriptWebSimple
{
public function DetermineEnvironnement()
{
// Déclaration
$this->Tabl1 = new PvTableauDonneesHtml() ;
// Chargement de la config
$this->Tabl1->AdopteScript("tabl1", $this) ;
$this->Tabl1->ChargeConfig() ;
// Définition des filtres de sélection
$this->Flt1 = $this->Tabl1->InsereFltSelectHttpGet("expression", "champ1 like concat(<self>, '%')") ;
$this->Flt1->Libelle = "Expression" ;
// Définition des colonnes
$this->Tabl1->InsereDefColCachee("id") ;
$this->Tabl1->InsereDefCol("champ1", "Champ 1") ;
$this->Tabl1->InsereDefCol("champ2", "Champ 2") ;
// Définition du fournisseur de données
$this->Tabl1->FournisseurDonnees = new PvFournisseurDonneesSql() ;
$this->Tabl1->FournisseurDonnees->BaseDonnees = new MaBD1() ;
$this->Tabl1->FournisseurDonnees->RequeteSelection = "matable1" ;
}
public function RenduSpecifique()
{
$ctn = '' ;
$ctn .= $this->Tabl1->RenduDispositif() ;
return $ctn ;
}
}

==== Filtres de sélection

[cols=",",options="header",]
|=========================================================================================================================================================================================================
|*Méthode* |*Description*
|InsereFltSelectHttpGet($nom, $exprDonnees='', $nomClsComp='') |Ajoute un filtre http GET
|InsereFltSelectHttpPost($nom, $exprDonnees='', $nomClsComp='') |Ajoute un filtre http POST
|InsereFltSelectHttpUpload($nom, $cheminDossierDest="", $exprDonnees='', $nomClsComp='') |Ajoute un filtre http UPLOAD. Tous les fichiers téléchargés seront déposés dans le répertoire $cheminDossierDest
|InsereFltSelectSession($nom, $exprDonnees='', $nomClsComp='') |Ajoute un filtre contenant la valeur d’une session
|InsereFltSelectFixe($nom, $valeur, $exprDonnees='', $nomClsComp='') |Ajoute un filtre basé sur une valeur fixe
|InsereFltSelectCookie($nom, $exprDonnees='', $nomClsComp='') |Ajoute un filtre contenant la valeur d’un cookie
|=========================================================================================================================================================================================================

==== Définitions de colonne

[cols=",",options="header",]
|===========================================================================================================================================================================================================================================
|*Propriété / Méthode* |*Description*
|$DefinitionColonnes |Tableau des définitions de colonne
|InsereDefColCachee($nomDonnees, $aliasDonnees="") |Inscrit une définition de colonne cachée.
|InsereDefColInvisible($nomDonnees, $aliasDonnees="") |
|InsereDefCol($nomDonnees, $libelle="", $aliasDonnees="") |Inscrit une définition de colonne, avec un libellé.
|InsereDefColBool($nomDonnees, $libelle="", $aliasDonnees="", $valPositive="", $valNegative="") |Inscrit une définition de colonne qui affiche un libellé en fonction d’une valeur booléenne.
|InsereDefColChoix($nomDonnees, $libelle="", $aliasDonnees="", $valsChoix=array()) |Inscrit une définition de colonne qui affiche un libellé en fonction d’une valeur.
|InsereDefColMonnaie($nomDonnees, $libelle="", $aliasDonnees="") |Inscrit une définition de colonne au format monétaire
|InsereDefColMoney($nomDonnees, $libelle="", $aliasDonnees="") |
|InsereDefColDateFr($nomDonnees, $libelle="", $inclureHeure=0) |Inscrit une définition de colonne au format Français (dd/mm/yyyy). Si $inclureHeure est égal à 1, l’heure sera affichée également.
|InsereDefColDateTimeFr($nomDonnees, $libelle="", $aliasDonnees="") |Inscrit une définition de colonne au format Français (dd/mm/yyyy hh:mi:ss)
|InsereDefColDetail($nomDonnees, $libelle="", $aliasDonnees="") |Inscrit une définition de colonne, qui affiche les 1ers caractères de la ligne. Si vous posez le curseur sur cette cellule, un bloc contenant le texte intégral apparaîtra.
|InsereDefColHtml($modeleHtml="", $libelle="") |Inscrit une définition de colonne qui affichera un contenu HTML.
|InsereDefColTimestamp($nomDonnees, $libelle="", $formatDate="d/m/Y H:i:s") |Inscrit une définition de colonne qui affichera une date à partir d’un timestamp
|InsereDefColActions($libelle, $actions=array()) |Inscrit une définition de colonne affichera des liens.
|===========================================================================================================================================================================================================================================

==== Source de valeurs supplémentaires

Vous pouvez étendre les lignes calculées dans le tableau de données. Utilisez la propriété *$SourceValeursSuppl*. Etendez la classe *PvSrcValsSupplLgnDonnees* pour réécrire sa méthode *Applique(& $composant, $ligneDonnees)*.

Vous utiliserez ces nouvelles valeurs uniquement dans une définition de colonne HTML.

[source,php]
class SrcValsSuppl1 extends PvSrcValsSupplLgnDonnees
{
public function Applique(& $composant, $ligneDonnees)
{
$results = array('menu' => '<a href="?appelleScript=developper&id='.urlencode($ligneDonnees ["id"]).'">+</a>') ;
return array_merge($ligneDonnees, $results) ;
}
}
class MonScript1 extends PvScriptWebSimple
{
public function DetermineEnvironnement()
{
$this->Tabl1 = new PvTableauDonneesHtml() ;
$this->Tabl1->AdopteScript("tabl1", $this) ;
$this->Tabl1->ChargeConfig() ;
// ...
$this->Tabl1->SourceValeursSuppl = new SrcValsSuppl1() ;
// ...
$this->Tabl1->InsereDefColCachee("id") ;
$this->Tabl1->InsereDefColHtml('$\{menu} $\{id}', 'Actions') ;
}

}

==== Autres propriétés

[cols=",",options="header",]
|=======================================================================
|*Propriété / Méthode* |*Description*
|$Largeur |Largeur du formulaire de filtres
|$LargeurFormulaireFiltres |Largeur du formulaire de filtres
|$AlignFormulaireFiltres |Alignement du formulaire de filtres
|$MessageAucunElement |Message lorsqu’il n’y a aucun élément trouvé
|$ElementsEnCours |Tableau contenant toutes les lignes trouvées
|$AlerterAucunElement |Affichera le message s’il n’y a aucun élément
|$TriPossible |Permettra le tri
|$TotalElements |Nombre de lignes retournées
|$CacherNavigateurRangees |Cacher le navigateur de rangées
|$CacherFormulaireFiltres |Cacher le formulaire de filtres
|$CacherBlocCommandes |Cacher le bloc de commandes
|$MaxElementsPossibles = array(20) |Nombres maximum de lignes par rangée
|=======================================================================

==== Liens d’action

[cols=",",options="header",]
|===============================================================================================================================================================
|*Méthode* |*Description*
|InsereLienAction(& $col, $formatUrl='', $formatLib='') |Inscrit un lien dans la colonne Action $col.
|InsereLienActionAvant(& $col, $index, $formatUrl='', $formatLib='') |Inscrit un lien dans la colonne Action $col à la position $index
|InsereIconeAction(& $col, $formatUrl='', $formatCheminIcone='', $formatLib='') |Inscrit une icône dans la colonne Action $col.
|InsereIconeActionAvant(& $col, $index, $formatUrl='', $formatCheminIcone='', $formatLib='') |Inscrit une icône dans la colonne Action $col à la position $index
|===============================================================================================================================================================

==== Commandes

[cols=",",options="header",]
|======================================================================================================================================
|*Propriété / Méthode* |*Description*
|$Commandes |Tableau contenant toutes les commandes
|InsereCommande($nom, $commande) |Inscrit une commande dans le tableau
|InscritCmdRafraich($libelle='Actualiser', $cheminIcone='') |Inscrit une commande qui soumet le formulaire de filtres
|InsereCmdRedirectUrl($nomCmd, $url, $libelle='') |Inscrit une commande qui redirige sur une URL
|InsereCmdRedirectScript($nomCmd, $nomScript, $libelle='', $params=array()) |Inscrit une commande qui redirige sur un script de la zone
|InsereCmdScriptSession($nomCmd, $libelle='', $urlDefaut=array()) |Inscrit une commande qui redirige sur le script session de la zone
|InsereCmdExportTexte($nomCmd, $libelle='') |Inscrit une commande qui exporte les résultats au format texte (CSV)
|InsereCmdExportExcel($nomCmd, $libelle='') |Inscrit une commande qui exporte les résultats au format HTML pour Excel
|======================================================================================================================================

==== Rendu du formulaire de données

Vous pouvez personnaliser le rendu du formulaire de filtres avec sa propriété *$DessinateurFiltresSelection*.

Référez-vous au link:#rendu-du-formulaire-de-filtres[[.underline]#rendu des filtres d’édition du formulaire de données#] pour l’utilisation.

=== Les filtres de données http

==== Présentation

Ils sont surtout utilisés dans les formulaires et les tableaux de données.

Ils vous proposent des champs de saisie, qui seront soumis après validation.

==== Propriétés et Méthodes principales

[cols=",",options="header",]
|==================================================================================================================
|*Propriété / Méthode* |*Description*
|$Libelle |Libellé
|$EstEtiquette |Si la valeur est 1, le filtre affichera la valeur au lieu du champ de saisie.
|$ValeurVide |Valeur NULLE du filtre.
|$ValeurParDefaut |Valeur par défaut
|$NePasLierParametre |Renvoie toujours la valeur par défaut du filtre.
|$NomParametreLie |Nom du paramètre soumis par http
|$NePasLireColonne |Ne change pas la valeur de la colonne liée au filtre. Utilisée dans les formulaires de données.
|$AliasParametreDonnees a|
Expression de la colonne de données

[source,]
Ex. TO_CHAR(<self>)

|$ExpressionDonnees a|
Condition SQL lorsque le filtre est utilisé dans une recherche.

[source,]
Ex : MON_CHAMP = <self>

|$NomColonneLiee |Nom de la colonne dans la table, pour un filtre d’édition
|$ExpressionColonneLiee a|
Expression de la colonne dans la table, pour un filtre d’édition.

[source,]
Ex. PASSWORD(<self>)

|$LectureSeule |Passer la valeur par défaut du filtre de données, et la soumettre dans le formulaire.
|$Invisible |Le filtre ne sera pas affiché sur la page. Il renvoie toujours sa valeur par défaut
|$NePasIntegrerParametre |Empêche le formulaire de données d’utiliser ce filtre pour la recherche.
|Lie() |Définit la valeur soumise à partir du formulaire. Elle est utilisée après clic sur : +
- une commande de formulaire donnée +
- le bouton « Rechercher » du tableau de données
|$DejaLie |Signale si le filtre a été lié déjà.
|$ValeurParametre |Valeur liée. Utilisez plutôt la méthode *Lie()*.
|$Role |Type du filtre de données.
|$TypeLiaisonParametre |Contient la valeur : +
- "get" : valeur issue de $_GET +
- "post" : valeur issue de $_POST
|==================================================================================================================

==== Correcteur de valeur

C’est une propriété qui encode/décode la valeur brute d’un filtre.

Vous devez étendre la classe *PvCorrecteurValeurFiltreBase* et réécrire les méthodes clées.

[source,php]
class MonCorrectValFiltre1 extends PvCorrecteurValeurFiltreBase
{
public function Applique($valeur, & $filtre)
{
return htmlentities($valeur) ;
}
}
class MonScript1 extends PvScriptWebSimple
{
public function DetermineEnvironnement()
{
// ...
$form = new PvFormulaireDonneesHtml() ;
// ...
$flt1 = $form->InsereFltEditHttpPost("flt1", "") ;
$flt1->CorrecteurValeur = new MonCorrectValFiltre1() ;
}
}

Il existe des correcteurs de valeurs déjà déclarés.

[cols=",",options="header",]
|==================================================================
|*Classe* |*Description*
|PvCorrecteurValeurFiltreBase |Correcteur de valeur par défaut
|PvCorrecteurValeurSansAccent |Enlève tous les caractères spéciaux.
|==================================================================

==== Composant de filtre

===== Présentation

Le composant de filtre de données est le champ de saisie. Vous le définissez ainsi :

[cols=",",options="header",]
|========================================================================================
|*Méthode* |*Description*
|DeclareComposant($nomClasseComposant) |Définit le composant à partir du nom de la classe
|RemplaceComposant($composant) |Définit le composant à partir de l’instance
|========================================================================================

Exemple :
[source,php]
$flt1 = $form->InsereFltEditHttpPost("monchamp") ;
// Le composant est dans la variable $comp1
$comp1 = $flt1->DeclareComposant("PvZoneMultiligneHtml") ;

===== Composants Eléments HTML

[cols=",",options="header",]
|================================================================================
|*Classe* |*Description*
|PvZoneTexteHtml |Composant par défaut affectée au filtre. Affiche un champ INPUT
|PvZoneMultiligneHtml |Affiche un champ TEXTAREA
|PvZoneMotPasseHtml |Affiche un champ PASSWORD
|PvZoneEtiquetteHtml |Affiche un champ en lecture seule.
|================================================================================

===== Composants de liste

Les composants de liste utilisent un fournisseur de données pour leur rendu.

[source,php]
$comp1 = $flt1->DeclareComposant("PvZoneSelectHtml") ;
// Définition du fournisseur de données
$comp1->FournisseurDonnees = new PvFournisseurDonneesSql() ;
$comp1->FournisseurDonnees->BaseDonnees = new MaBD1() ;
$comp1->FournisseurDonnees->RequeteSelection = "matable1" ;
// Définition des valeurs
$comp1->NomColonneValeur = "id" ;
// Définition de l'affichage
$comp1->NomColonneLibelle = "monchamp1" ;
// Afficher une valeur par defaut s’il n’y a aucune valeur
$comp1->InclureElementHorsLigne = 1 ;
$comp1->ValeurElementHorsLigne = -1 ;
$comp1->LibelleElementHorsLigne = " – Aucun --" ;

[cols=",",options="header",]
|===============================================================================================================
|*Classe* |*Description*
|PvZoneBoiteSelectHtml |Affiche une zone SELECT
|PvZoneBoiteOptionsRadioHtml |Affiche une zone de plusieurs options RADIO à cocher.
|PvZoneBoiteOptionsCocherHtml a|
Affiche une zone de plusieurs options CHECKBOX à cocher.

Pour récupérer toutes les valeurs cochées, utilisez la propriété $ValeurBrute du filtre.

|PvZoneCadreOptionsRadioHtml |Affiche une zone de plusieurs options RADIO à cocher, dans un IFRAME HTML
|===============================================================================================================

===== Formatage de libellé

Si le filtre de données est en étiquette, son champ de saisie ne sera pas éditable.

Pour personnaliser ce rendu, utilisez la méthode *DefinitFmtLbl*. Etendez la classe *PvFmtLblBase* et réécrivez sa méthode *Rendu($valeur, & $composant)*.

[source,php]
class MonFmtLbl1 extends PvFmtLblBase
{
public function Rendu($valeur, & $composant)
{
return base64_decode($valeur) ;
}
}

Ensuite, affectez ce format au composant avec la méthode *DefinitFmtLbl()* du filtre. Vous devez déclarer le composant avant d’utiliser cette méthode.

[source,php]
$comp = $flt1->DeclareComposant("PvZoneTexteHtml") ;
// …
$flt1->DefinitFmtLbl(new MonFmtLbl1()) ;

Voici des formats déjà définis :

[cols=",",options="header",]
|============================================================
|*Classe* |*Description*
|PvFmtLblBase |Classe de base.
|PvFmtLblWeb |Classe affectée par défaut
|PvFmtLblDateFr |Affiche au format date français
|PvFmtLblDateTimeFr |Affiche au format date et heure français
|PvFmtMonnaie |Affiche au format monétaire
|============================================================

==== Le filtre de données Upload

Le filtre de données Upload télécharge un fichier.

===== Propriétés / Méthodes principales

[cols=",",options="header",]
|================================================================================================================================================================
|*Propriété / Méthodes* |*Description*
|$NettoyerCaractsFichier |Enlève les caractères spéciaux du nom fichier téléchargé.
|$ExtensionsAcceptees |Tableau contenant les extensions uniquement acceptées. Si le fichier soumis n’a pas une extension, il ne sera pas copié dans le répertoire
|$ExtensionsRejetees |Tableau contenant les extensions à rejeter systématiquement.
|$FormatFichierTelech a|
Format du nom de fichier téléchargé. Variables disponibles : +
- Cle : Identifiant Unique +
- NombreAleatoire : Nombre compris entre 1 & 10000 +
- NomFichier : Nom d’origine du fichier +
- Timestamp : Timestamp actuel +
- Date : Date au format YmdHis

[source,]
Ex : "Bon-Commande-$\{Cle}"

|$SourceTelechargement |Contient les valeurs suivantes : +
- post : Aucun fichier n’est soumis +
- files : Un fichier a été soumis
|$InfosTelechargement |Contient les détails du fichier téléchargé.
|$ToujoursRenseignerFichier |Renvoie une erreur dans le formulaire de données, si aucun fichier n’est soumis.
|================================================================================================================================================================

===== Caractéristique du Composant

Le composant par défaut de ce filtre est le composant *PvZoneUploadHtml*.

Ses propriétés principales sont :

[cols=",",options="header",]
|======================================================================================
|*Propriété* |*Description*
|$InclureErreurTelecharg |Afficher l’erreur survenue lors du téléchargement
|$InclureCheminCoteServeur |Afficher le chemin relatif du fichier téléchargé
|$InclureZoneSelectFichier |Afficher les informations sur le fichier téléchargé
|$CheminCoteServeurEditable |Autoriser la modification du chemin relatif sur le serveur
|$InclureApercu |Valeurs possibles : +
- 0 : Ne pas autoriser d’aperçu +
- 1 : Affiche un lien pour afficher dans le navigateur +
- 2 : Afficher le fichier dans un cadre, si c’est possible
|$LargeurCadreApercu |Largeur HTML du cadre d’aperçu
|$HauteurCadreApercu |Hauteur HTML du cadre d’aperçu.
|======================================================================================

=== La Grille de données HTML

La grille de données affiche les lignes d'enregistrement sur une grille. Elle se base sur le tableau de données.

[cols=",",options="header",]
|======================================================================================
|*Propriété* |*Description*
|$ContenuLigneModele |Format de la cellule. Vous incorporez les colonnes de données à partir de leur noms. +
Ex. ${id}
|$EmpilerValeursSiModLigVide |Empile les valeurs de toutes les colonnes si $ContenuLigneModele est vide.
|$AlignVCellule |Alignement HTML vertical de la cellule
|$MaxColonnes |Nombre de colonnes Maximum à afficher.
|======================================================================================

[source,php]
class MonScript1 extends PvScriptWebSimple
{
// ....
public function DetermineEnvironnement()
{
//Initiation
$grille = new PvGrilleDonneesHtml() ;
$grille->AdopteScript("grille", $this) ;
$grille->ChargeConfig() ;
// Définition des colonnes
$grille->InsereDefCol("id") ;
$grille->InsereDefCol("titre") ;
$grille->InsereDefCol("description") ;
// Définition des autres propriétés
$grille->MaxColonnes = 3 ;
$grille->ContenuLigneModele = '<h4>${id}. ${titre}</h4>
<p>${description}</p>' ;
// définir le fournisseur de données...
}
}

== La classe Tache Programmée

La tâche programmée est un composant de l'application, pour exécuter des instructions à un moment précis.

=== Utilisation

* Vous devez réecrire une classe héritant de la tache *PvTacheProg*. Réécrivez la méthode *ExecuteSession()*, qui contient le code à exécuter.
* Dans la déclaration de votre application, réécrivez la méthode *ChargeTachesProgs()*. Invoquez *InsereTacheProg($nom, $tacheProg)* pour inscrire votre tache programmée

[source,php]
class MaTacheProg1 extends PvTacheProg
{
public $CheminFichierRelatif = "monApp/tache1.php" ;
protected function ExecuteSession()
{
echo "Ma tache a ete executee" ;
}
}
class MonApplication1 extends PvApplication
{
protected function ChargeTachesProgs()
{
$this->Tache1 = $this->InsereTacheProg("maTache1", new MaTacheProg1()) ;
}
}

=== Planification

Utilisez le planificateur de tâche de votre système d'exploitation (crontab, ...).

=== Contexte d'exécution

La tâche programmée s'exécute en ligne de commande par défaut. Pour l'afficher dans un navigateur, mettez la propriété *$NaturePlateforme* à "WEB".

[source,php]
class MaTacheProg1 extends PvTacheProg
{
public $CheminFichierRelatif = "monApp/tache1.php" ;
public $NaturePlateforme = "WEB" ;
// ...
}

== La classe Service Persistant

Le service persistant est un daemon PHP. Une fois exécutée, il ne s'arrête jamais.

Il s'exécute uniquement par ligne de commande.

=== Utilisation

* Vous devez réecrire une classe héritant de la tache *PvServicePersist*. Réécrivez la méthode *ExecuteSession()*, qui contient le code à exécuter.
* Dans la déclaration de votre application, réécrivez la méthode *ChargeServsPersists()*. Invoquez *InsereServPersist($nom, $servPersist)* pour inscrire votre service

[source,php]
class MonService1 extends PvServicePersist
{
public $CheminFichierRelatif = "monApp/service1.php" ;
protected function ExecuteSession()
{
echo "Mon service est en cours d'execution\n" ;
}
}
// Déclaration de la classe Application
class MonApplication1 extends PvApplication
{
// ...
protected function ChargeServsPersists()
{
$this->Service1 = $this->InsereServPersist("monServ1", new MonService1()) ;
}
}

=== Propriétés principales

[cols=",",options="header",]
|======================================================================================
|*Propriété* |*Description*
|$DelaiAttente |Délai avant de recommencer la boucle(session)
|$DelaiEtatInactif |Délai avant de considerer le service comme inactif ou planté
|$MaxSessions |Maximum de boucle possible avant d'arrêter le service.
|$LimiterDelaiBoucle |Provoque une erreur fatale si la session prend trop de temps
|$DelaiBoucle |Délai maximum pour exécuter une boucle
|$Arreter |Arrêter le service une fois la session exécutée.
|======================================================================================

==== L'état d'un service

C'est la capture qui témoigne de l'état d'un service. Elle contient les informations suivantes :
* PID : ID du processus
* Statut : 1=démarré, 2=stoppé
* TimestmpCapt : Timestamp de la capture
* TimestmpDebutSession : Timestamp de démarrage de la session en cours
* TimestmpFinSession : Timestamp de la fin de la session en cours

Le service persistant sauvegarde cette capture dans un fichier, avec la méthode *SauveEtat()*.
Vous définissez le répertoire de ces captures avec la propriété $ChemRelRegServsPersists de la classe Application. Son fichier est du format "<nomService>.dat".

[source,php]
class MonService1 extends PvServicePersist
{
public $CheminFichierRelatif = "monApp/service1.php" ;
protected function ExecuteSession()
{
echo "Mon service est en cours d'execution\n" ;
// Sauvegarder l'état dans "monApp/data/monServ1.dat"
$this->SauveEtat() ;
echo "Traitement suivant...\n" ;
}
}
// Déclaration de la classe Application
class MonApplication1 extends PvApplication
{
// Définir le répertoire des états des services persistant
public $ChemRelRegServsPersists = "monApp/data" ;
// ...
protected function ChargeServsPersists()
{
$this->Service1 = $this->InsereServPersist("monServ1", new MonService1()) ;
}
}

== Organisation d’une solution PHP-PV

=== Dossiers principaux

Pour mieux organiser votre solution développée sous PHP-PV, nous vous recommandons de créer ces dossiers :

[cols=",",options="header",]
|===================================================================
|*Chemin* |*Description*
|/ |Racine de votre solution
|/lib |Contient toutes les classes de votre solution
|/consts |Contient les constantes
|/js |Contient tous les scripts Javascript
|/css |Contient tous les fichiers CSS
|/vendor |Contient toutes les librairies PHP/Javascript/CSS externes
|/index.php |Script PHP de la solution
|===================================================================

=== Structure du dossier lib

Dans le dossier « /lib », nous vous recommandons de créer les fichiers suivants :

[cols=",",options="header",]
|========================================================================================================================================
|*Fichier ou Répertoire* |*Rôle*
|/lib/Application.class.php |Déclaration de votre classe Application. Elle inclura toutes les librairies PHP et fichiers de ce répertoire
|/lib/Zone.class.php |Déclaration de votre classe Zone. Elle inclura les fichiers scripts
|/lib/Script.class.php |Elle inclura tous les scripts (/lib/Script.class.php)
|/lib/script/Noyau.class.php |Déclaration de vos scripts web de référence. Ces scripts seront étendus par les autres scripts
|========================================================================================================================================
